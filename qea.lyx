#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman times
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\topmargin 2cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip bigskip
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
title{Algoritmos Evolutivos inspirados en 
\backslash

\backslash
 Computación Cuántica}
\end_layout

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
large Rodrigo Arias Mallo
\backslash

\backslash
 Carlos Pérez Ramil
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Abstract
Este estudio tiene como objetivo presentar una serie de técnicas que tratan
 de combinar la forma de resolver problemas de los Algoritmos Evolutivos
 con los conceptos básicos de la Computación Cuántica, así como su repercusión
 y posibles aplicaciones en el mundo de la Robótica.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
Los Algoritmos Evolutivos son un método de resolución de problemas ampliamente
 desarrollado desde la década de 1980 hasta la actualidad.
 Utilizan los principios de la evolución biológica para operar sobre un
 conjunto de individuos que representa distintas soluciones a un problema
 determinado.
 Entre sus múltiples variantes encontramos una relativamente reciente, que
 toma algunos conceptos del campo emergente de la Computación Cuántica para
 modelar el individuo y la manera en que este evoluciona.
 Hay que tener presente que no se trata de un algoritmo cuántico, sino de
 un algoritmo clásico, pensado para ser ejecutado en un computador clásico,
 pero que utiliza conceptos de Computación Cuántica como son el 
\emph on
qbit
\emph default
 o la superposición de estados.
 Por eso se les denomina 
\begin_inset Quotes fld
\end_inset

Algoritmos Evolutivos inspirados en Computación Cuántica
\begin_inset Quotes frd
\end_inset

 (QEA, por sus siglas en inglés).
\end_layout

\begin_layout Subsection
Computación Evolutiva
\end_layout

\begin_layout Standard
La Computación Evolutiva es una rama de la Inteligencia Artificial que trata
 principalmente problemas de optimización.
 Surge con la idea de aplicar los principios de la evolución biológica a
 la resolución de problemas complejos.
 En particular, se basa en los conceptos de 
\emph on
selección natural, recombinación genética 
\emph default
y 
\emph on
mutación.
 
\emph default
Las primeras aproximaciones datan de los años 50, pero no se consagra como
 disciplina hasta la década de los 70.
 Desde entonces se ha realizado mucha investigación en este campo, y encontramos
 innumerables aplicaciones en todo tipo de contextos, no sólo de carácter
 científico-técnico, sino también artístico, económico o social.
\end_layout

\begin_layout Standard
Existen tres grandes subcampos de la Computación Evolutiva, entre muchos
 otros de distinta relevancia:
\end_layout

\begin_layout Itemize

\emph on
Algoritmos Genéticos
\emph default
.
 Modelan las posibles soluciones de un problema como individuos de una población
, y las distintas variables como su información genética.
 Funcionan de forma iterativa, simulando las distintas generaciones de la
 población, y aplicando los operadores genéticos de selección, cruce y mutación
 de manera estocástica.
\end_layout

\begin_layout Itemize

\emph on
Programación Genética
\emph default
.
 Similar a los Algoritmos Genéticos, pero en este caso las soluciones son
 programas, y su calidad se determina en función de su capacidad para resolver
 un problema computacional.
\end_layout

\begin_layout Itemize

\emph on
Estrategias Evolutivas
\emph default
.
 Utilizan variables adicionales para controlar el proceso de evolución de
 forma dinámica.
\end_layout

\begin_layout Standard
Los algoritmos evolutivos son adecuados para problemas en los que el espacio
 de búsqueda es muy grande y no hay una solución analítica conocida.
 Esto los hace especialmente adecuados para ciertos problemas de Robótica,
 como son el diseño de morfologías o de controladores.
 Sin embargo, presentan ciertos inconvenientes.
 En primer lugar, no garantizan que se encuentre el óptimo global.
 Y en caso de alcanzar a una solución aceptable, resulta muy difícil (o
 casi imposible, en algunos casos) averiguar cómo y por qué se ha llegado
 hasta esa solución.
\end_layout

\begin_layout Subsection
Computación Cuántica
\end_layout

\begin_layout Standard
La computación cuántica es un nuevo paradigma de computación.
 Emplea las propiedades especiales de la materia que suceden en una escala
 más pequeña.
\end_layout

\begin_layout Standard
El objetivo que busca la computación cuántica es el de hacer uso de las
 propiedades inherentes a la naturaleza para realizar computaciones.
 De la misma forma que los ordenadores clásicos que acostumbramos a emplear,
 existe una analogía cuántica; el ordenador cuántico.
 Los bits se convierten en qbits.
 La representación del estado de un qbit 
\begin_inset Formula $\left|\psi\right\rangle $
\end_inset

 es:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left|\psi\right\rangle =\left(\begin{array}{c}
\alpha\\
\beta
\end{array}\right)=\alpha\left(\begin{array}{c}
1\\
0
\end{array}\right)+\beta\left(\begin{array}{c}
0\\
1
\end{array}\right)=\alpha\left|0\right\rangle +\beta\left|1\right\rangle 
\]

\end_inset


\end_layout

\begin_layout Standard
Donde 
\begin_inset Formula $\alpha,\beta\in\mathbb{C}$
\end_inset

 y también 
\begin_inset Formula $\left|\alpha\right|^{2}+\left|\beta\right|^{2}=1$
\end_inset

.
 La medición de un qbit resultará en 0 o bien en 1.
 De forma que la probabilidad de que resulte 0 es 
\begin_inset Formula $|\alpha|^{2}$
\end_inset

 y de que resulte 1 es 
\begin_inset Formula $|\beta|^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Una ventaja frente a la computación clásica es la superposición de estados.
 Para un sistema 
\begin_inset Formula $\left|\psi\right\rangle $
\end_inset

 de n qbits:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left|\psi\right\rangle =\bigotimes^{n}\left(\begin{array}{c}
\alpha_{i}\\
\beta_{i}
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
No es necesario que cada qbit individual cumpla 
\begin_inset Formula $\left|\alpha_{i}\right|^{2}+\left|\beta_{i}\right|^{2}=1$
\end_inset

, si no que 
\begin_inset Formula 
\[
\sum^{n}\left|\alpha_{i}\right|^{2}+\sum^{n}\left|\beta_{i}\right|^{2}=1
\]

\end_inset

De forma que se pueden construir estados especiales, que no son posibles
 en los bits clásicos, por ejemplo el estado de Bell, denominado 
\begin_inset Formula $\left|B_{00}\right\rangle $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left|B_{00}\right\rangle =\frac{1}{\sqrt{2}}\left(\left|00\right\rangle +\left|11\right\rangle \right)
\]

\end_inset


\end_layout

\begin_layout Standard
La probabilidad de que se obtenga como resultado de una medición 01 o 10,
 es nula.
 Sin embargo, la probabilidad de obtener 00 o bien 11 es 
\begin_inset Formula $\frac{1}{2}$
\end_inset

.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Estado del arte
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
El concepto de QEA
\end_layout

\begin_layout Standard
A.
 Narayanan y M.
 Moore 
\begin_inset CommandInset citation
LatexCommand cite
key "Narayanan1996"

\end_inset

 fueron los primeros en proponer la idea de los QEA en 1996.
 Sin embargo, se utilizará el trabajo de Kuk-Hyun Han y Jong-Hwan Kim 
\begin_inset CommandInset citation
LatexCommand cite
key "Han2003,Han2002_2,Han2002"

\end_inset

 como guía para exponer el algoritmo, por el mayor nivel de detalle que
 hay en su trabajo.
 Ellos proponen el siguiente esquema general para QEA.
\end_layout

\begin_layout Subsection
Representación
\end_layout

\begin_layout Standard
Un individuo posee un solo cromosoma que se modela como un vector de qbits:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left[\begin{pmatrix}\alpha_{1}\\
\beta_{1}
\end{pmatrix},\begin{pmatrix}\alpha_{2}\\
\beta_{2}
\end{pmatrix},...,\begin{pmatrix}\alpha_{m}\\
\beta_{m}
\end{pmatrix}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
donde 
\begin_inset Formula $\left|\alpha_{i}\right|^{2}+\left|\beta_{i}\right|^{2}=1$
\end_inset

 para 
\begin_inset Formula $i=1,2,...,m$
\end_inset

.
 Se utilizan los valores de probabilidad de cada qbit para simular el concepto
 de superposición de estados, de forma que un individuo contiene información
 acerca de todas las soluciones simultáneamente.
 Lo que se pretende con esta representación es aumentar la variabilidad
 genética en la población, ya que la información transmitida a lo largo
 de las generaciones son valores de probabilidad de todas las secuencias
 posibles, y no secuencias concretas.
\end_layout

\begin_layout Subsection
Algoritmo
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

procedure QEA
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	t = 0
\end_layout

\begin_layout Plain Layout

1)  initialize Q(t)
\end_layout

\begin_layout Plain Layout

2)  make P(t) by observing the states of Q(t)
\end_layout

\begin_layout Plain Layout

3)  evaluate P(t)
\end_layout

\begin_layout Plain Layout

4)  store the best solutions among P(t) into B(t)
\end_layout

\begin_layout Plain Layout

	while (not termination-condition) do
\end_layout

\begin_layout Plain Layout

	begin
\end_layout

\begin_layout Plain Layout

		t = t + 1
\end_layout

\begin_layout Plain Layout

5)  	make P(t) by observing the states of Q(t-1)
\end_layout

\begin_layout Plain Layout

6)  	evaluate P(t)
\end_layout

\begin_layout Plain Layout

7)  	update Q(t) using Q-gates
\end_layout

\begin_layout Plain Layout

8)  	store the best solutions among B(t-1) and P(t) into B(t)
\end_layout

\begin_layout Plain Layout

9)  	store the best solution b among B(t)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esquema del algoritmo QEA
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Q(t)=\left\{ q_{1}^{t},q_{2}^{t},...,q_{n}^{t}\right\} $
\end_inset

 es la población en el instante 
\begin_inset Formula $t$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $P(t)=\left\{ x_{1}^{t},x_{2}^{t},...,x_{n}^{t}\right\} $
\end_inset

 es un conjunto de soluciones en el instante 
\begin_inset Formula $t$
\end_inset

, resultante de efectuar una medición en cada individuo de 
\begin_inset Formula $Q(t)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $B(t)=\left\{ b_{1}^{t},b_{2}^{t},...,b_{n}^{t}\right\} $
\end_inset

 es el conjunto de mejores soluciones obtenidas hasta el instante 
\begin_inset Formula $t$
\end_inset

.
 
\begin_inset Formula $\mathbf{b}$
\end_inset

 es la mejor solución global.
\end_layout

\begin_layout Standard
El algoritmo no es un algoritmo cuántico, si no que se ejecuta en un ordenador
 clásico, por lo que es posible determinar el estado de un qbit, sin que
 este se colapse.
 De esta forma, de un vector de qbits 
\begin_inset Formula $\mathbf{q}\in Q(t)$
\end_inset

 es posible realizar una medición en el vector binario 
\begin_inset Formula $\mathbf{x}\in P(t)$
\end_inset

, sin modificar 
\begin_inset Formula $\mathbf{q}$
\end_inset

.
\end_layout

\begin_layout Standard
1.
 Los qbits de los cromosomas se inicializan con valores de igual probabilidad
 para todos los estados.
\end_layout

\begin_layout Standard
2.
 Para cada individuo 
\begin_inset Formula $j=1,2,...,n$
\end_inset

, se realiza una medición de los qbits del cromosoma 
\begin_inset Formula $\mathbf{q_{j}}$
\end_inset

.
 En el vector 
\begin_inset Formula $\mathbf{x_{j}}$
\end_inset

 se almacena el estado del cromosoma colapsado, que formará la solución.
 
\end_layout

\begin_layout Standard
3.
 Evalúa el resultado de cada individuo 
\begin_inset Formula $\mathbf{x_{j}}$
\end_inset

 empleando una función de 
\emph on
fitness
\emph default
.
\end_layout

\begin_layout Standard
4.
 Selecciona las mejores soluciones tras evaluar cada 
\begin_inset Formula $\mathbf{x_{j}}$
\end_inset

, y se almacenan en 
\begin_inset Formula $B(t)$
\end_inset

.
 Obviamente, 
\begin_inset Formula $B(t)=P(t)$
\end_inset

 cuando 
\begin_inset Formula $t=0$
\end_inset

.
 
\end_layout

\begin_layout Standard
A continuación comienza un bucle que se repetirá hasta que lo indique la
 condición de parada.
\end_layout

\begin_layout Standard
5.
 Repite el procedimiento del paso 2, que consiste en medir el estado de
 los cromosomas de 
\begin_inset Formula $Q(t-1)$
\end_inset

 en 
\begin_inset Formula $P(t)$
\end_inset

.
 Sin alterar el estado del cromosoma.
\end_layout

\begin_layout Standard
6.
 Evalúa 
\begin_inset Formula $\mathbf{x_{j}}$
\end_inset

 para cada 
\begin_inset Formula $j=1,2,...,n$
\end_inset

.
\end_layout

\begin_layout Standard
7.
 Realiza una modificación en el valor de los qbits de cada individuo.
 Consiste en una trasformación aplicando una puerta cuántica de rotación.
 Se acerca el valor de cada qbit a 
\begin_inset Formula $\left|0\right\rangle $
\end_inset

 o a 
\begin_inset Formula $\left|1\right\rangle $
\end_inset

, aumentando o reduciendo el valor de 
\begin_inset Formula $\alpha$
\end_inset

 y de 
\begin_inset Formula $\beta$
\end_inset

 en función de la variación del 
\emph on
fitness 
\emph default
con respecto al mejor actual.
 De esta forma, cada vez existen más probabilidades de que el valor resultante
 de medir proporcione un resultado más acercado al indicado por la función
 de 
\emph on
fitness
\emph default
.
\end_layout

\begin_layout Standard
8.
 Almacena las mejores soluciones de entre 
\begin_inset Formula $B(t-1)$
\end_inset

 y 
\begin_inset Formula $P(t)$
\end_inset

 en 
\begin_inset Formula $B(t)$
\end_inset

.
 Vuelve al paso 5.
\end_layout

\begin_layout Standard
Al finalizar, el vector 
\begin_inset Formula $\mathbf{b}$
\end_inset

 contendrá la mejor solución alcanzada, en forma de vector binario.
\end_layout

\begin_layout Standard
El algoritmo propuesto por Han 
\begin_inset CommandInset citation
LatexCommand cite
key "Han2003,Han2002_2,Han2002"

\end_inset

 no emplea las operaciones habituales de cruce ni de mutación para producir
 la siguiente generación de individuos.
 Sin embargo, otras publicaciones sí hacen uso de ellos (citar autores).
 
\end_layout

\begin_layout Subsection
Rendimiento
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Aplicaciones
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Conclusiones
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "qea"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
